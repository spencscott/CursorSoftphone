<!DOCTYPE html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Open Phone</title>
    <script src="jssip-3.10.0.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Roboto', sans-serif;
            background-color: #f5f5f5;
            color: #333;
            line-height: 1.6;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 24px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            width: 100%;
            max-width: 400px;
            padding: 24px;
            position: relative;
            overflow: hidden;
        }

        .title {
            color: #1a73e8;
            font-size: 24px;
            font-weight: 400;
            text-align: center;
            margin-bottom: 16px;
        }

        .input-group {
            margin-bottom: 16px;
            position: relative;
        }

        .input-group input {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid #dadce0;
            border-radius: 8px;
            font-size: 16px;
            transition: all 0.3s;
            outline: none;
        }

        .input-group input:focus {
            border-color: #1a73e8;
            box-shadow: 0 0 0 2px rgba(26,115,232,0.2);
        }

        .input-group label {
            position: absolute;
            left: 16px;
            top: 50%;
            transform: translateY(-50%);
            background: white;
            padding: 0 4px;
            color: #5f6368;
            transition: all 0.3s;
            pointer-events: none;
        }

        .input-group input:focus + label,
        .input-group input:not(:placeholder-shown) + label {
            top: 0;
            font-size: 12px;
            color: #1a73e8;
        }

        #status {
            text-align: center;
            margin: 16px 0;
            font-size: 14px;
            min-height: 20px;
        }

        button {
            border: none;
            cursor: pointer;
            transition: all 0.3s;
        }

        .dialpad {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            padding: 8px;
            opacity: 1;
            transition: opacity 0.3s ease-in-out;
        }

        .dial-digit {
            aspect-ratio: 1;
            font-size: 24px;
            border: none;
            border-radius: 12px;
            background: #f8f9fa;
            color: #3c4043;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            min-height: 48px;
        }

        .dial-digit:hover {
            background: #e8eaed;
        }

        .dial-digit:active {
            background: #dadce0;
            transform: scale(0.95);
        }

        .number-display-container {
            position: relative;
            display: flex;
            align-items: center;
            margin-bottom: 16px;
            gap: 8px;
        }

        #display {
            flex-grow: 1;
            background: #f8f9fa;
            padding: 12px;
            border-radius: 12px;
            min-height: 48px;
            display: flex;
            align-items: center;
            color: #3c4043;
        }

        .display-with-clear {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            padding-right: 4px !important;
        }

        #display-text {
            flex-grow: 1;
            text-align: center;
            font-size: 24px;
            margin-right: 8px;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            outline: none;
            border-radius: 4px;
        }

        #display-text:focus {
        }

        .clear-button {
            background: none;
            border: none;
            padding: 8px;
            color: #5f6368;
            cursor: pointer;
            transition: color 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 36px;
            width: 36px;
            height: 36px;
            flex-shrink: 0;
        }

        .clear-button:hover {
            color: #1a73e8;
            background: none;
        }

        .clear-button i {
            font-size: 20px;
        }

        .button-container {
            width: 100%;
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 8px;
            position: relative;
            min-height: 48px;
            margin: 16px 0;
        }

        .button-wrapper {
            flex: 1 1 auto;
            min-width: 120px;
            max-width: 200px;
            height: 48px;
            margin: 4px;
        }

        .button-wrapper.hidden {
            display: none;
            height: 0;
            margin: 0;
            padding: 0;
        }

        .call-button,
        .answer-button,
        .hangup-button,
        .record-button,
        .download-button {
            width: 100%;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 500;
        }

        .call-button,
        .answer-button {
            background: #34a853;
            color: white;
        }

        .hangup-button {
            background: #ea4335;
            color: white;
        }

        .hidden {
            display: none !important;
        }

        #softphone-ui {
            margin-top: 24px;
        }

        #mic-status {
            color: #34a853;
            background: #f1f8f1;
            padding: 8px 12px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }

        #selected-mic-name {
            font-weight: 500;
            max-width: 200px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        #mic-status.error {
            color: #ea4335;
            background: #fef7f6;
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5); /* Semi-transparent black overlay */
            display: none;
            z-index: 1000;
        }

        .modal-content {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            border-radius: 24px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            width: 100%;
            max-width: 400px;
            padding: 24px;
            z-index: 1001;
        }

        .close-btn {
            position: absolute;
            right: 10px;
            top: 10px;
            cursor: pointer;
            font-size: 24px;
        }

        select {
            width: 100%;
            padding: 12px;
            border: 1px solid #dadce0;
            border-radius: 8px;
            font-size: 16px;
            outline: none;
        }

        select:focus {
            border-color: #1a73e8;
            box-shadow: 0 0 0 2px rgba(26,115,232,0.2);
        }

        #call-status {
            background: #e8f5e9;
            border-radius: 8px;
            padding: 12px;
            margin: 0 0 24px 0;
            text-align: center;
        }

        .status-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
        }

        .status-text {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #34a853;
        }

        #call-timer {
            font-family: 'Roboto Mono', monospace;
            font-size: 16px;
            color: #1a73e8;
            font-weight: 500;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .calling {
            animation: pulse 1s infinite;
        }

        .toggle-dialpad {
            background: #1a73e8;
            color: white;
            border: none;
            border-radius: 50%;
            width: 48px;
            height: 48px;
            min-width: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background-color 0.3s ease;
            padding: 0;
            position: relative;
        }

        .toggle-dialpad i {
            font-size: 24px;
            transition: transform 0.3s ease;
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .toggle-dialpad.active {
            background: #34a853;
        }

        .toggle-dialpad.active i {
            transform: rotate(180deg);
        }

        .toggle-dialpad:hover {
            background: #1557b0;
        }

        .toggle-dialpad.active:hover {
            background: #2d9047;
        }

        .dialpad-container {
            transition: height 0.3s ease-in-out, opacity 0.3s ease-in-out;
            height: 0;
            opacity: 0;
            overflow: hidden;
        }

        .dialpad-container.visible {
            opacity: 1;
        }

        @media (max-width: 400px) {
            .container {
                padding: 16px;
                border-radius: 16px;
            }

            .dial-digit {
                font-size: 20px;
                min-height: 40px;
            }

            #display {
                font-size: 20px;
                min-height: 40px;
            }
        }

        #registerBtn {
            width: 100%;
            background: #1a73e8;
            color: white;
            padding: 12px 24px;
            font-size: 16px;
            border-radius: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Add hover states for buttons */
        .call-button:hover,
        .answer-button:hover {
            background: #2d9047;
        }

        .hangup-button:hover {
            background: #d33828;
        }

        .ringtone-container {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 8px;
        }

        .ringtone-button {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 8px 16px;
            background: #1a73e8;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .ringtone-button:hover {
            background: #1557b0;
        }

        #selectedRingtoneName {
            flex-grow: 1;
            font-size: 14px;
            color: #5f6368;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 150px;
        }

        .ringtone-preview {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: none;
            background: #e8f0fe;
            color: #1a73e8;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .ringtone-preview:hover {
            background: #d2e3fc;
        }

        .caption-container {
            background-color: #f8f9fa;
            position: relative;
            border-radius: 12px;
            margin-bottom: 16px;
            width: 100%;
            padding: 12px;
            color: #333;
            font-size: 16px;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100px;
            overflow-y: auto;
        }

        .captions {
            margin: 0 auto;
            text-align: center;
        }

        #settingsBtn {
            background: none;
            border: none;
        }

        #settingsBtn i {
            color: grey;
            transition: color 0.3s ease;
        }

        #settingsBtn:hover i {
            color: black;
        }

        .settings-container {
            position: absolute;
            top: 25px;
            right: 25px;
        }

        .icon-button {
            background: none;
            border: none;
            cursor: pointer;
            color: #5f6368;
            font-size: 24px;
        }

        .icon-button:hover {
            color: #1a73e8;
        }

        .record-button {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 500;
            background: #9c27b0;
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .record-button.recording {
            background: #d32f2f;
            animation: pulse 2s infinite;
        }

        .download-button {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 500;
            background: #1976d2;
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .record-button:hover {
            background: #7b1fa2;
        }

        .record-button.recording:hover {
            background: #c62828;
        }

        .download-button:hover {
            background: #1565c0;
        }

        .logo {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 24px;
            height: 24px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div class="container">
        <img src="https://static.wixstatic.com/media/705ac4_d055fcec7bda46da9d8c035aa63f3faa~mv2.png/v1/fill/w_35,h_35,al_c,q_85,usm_0.66_1.00_0.01,enc_avif,quality_auto/705ac4_d055fcec7bda46da9d8c035aa63f3faa~mv2.png" alt="App Logo" class="logo" style="position: absolute; top: 10px; left: 10px; width: 24px; height: 24px;">
        <h1 class="title">Open Phone</h1>
        
        <div id="call-status" style="display: none;">
            <div class="status-container">
                <div class="status-text">
                    <i class="material-icons">call</i>
                    <span id="call-state">Connected</span>
                </div>
                <div id="call-timer">00:00:00</div>
            </div>
        </div>

        <div class="settings-container">
            <button id="settingsBtn" class="icon-button">
                <i class="material-icons">settings</i>
            </button>
        </div>

        <div id="settingsModal" class="modal" style="display: none;">
            <div class="modal-content">
                <div class="modal-header">
                    <h2>Audio Settings</h2>
                    <button class="close-btn">
                        <i class="material-icons">close</i>
                    </button>
                </div>
                <div class="modal-body">
                    <div class="input-group">
                        <label for="micSelect">Microphone</label>
                        <select id="micSelect"></select>
                    </div>
                    <div class="input-group">
                        <label for="speakerSelect">Speaker</label>
                        <select id="speakerSelect"></select>
                    </div>
                    <div class="input-group">
                        <div class="ringtone-container">
                            <input type="file" id="ringtoneInput" accept="audio/*" style="display: none;">
                            <button id="selectRingtone" class="ringtone-button">
                                <i class="material-icons">music_note</i>
                                Ringtone
                            </button>
                            <span id="selectedRingtoneName">Default Ringtone</span>
                            <button id="playRingtone" class="ringtone-preview">
                                <i class="material-icons">play_arrow</i>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="registration">
            <div class="input-group">
                <input type="text" id="username" placeholder=" " value="sip:1010@loupdb.com">
                <label>SIP Username</label>
            </div>
            <div class="input-group">
                <input type="password" id="password" placeholder=" " value="joGUBrSo">
                <label>Password</label>
            </div>
            <div class="input-group">
                <input type="text" id="sipServer" placeholder=" " value="wss://alpha.netsapiens.com:9002">
                <label>WebSocket URL</label>
            </div>
            <button id="registerBtn">
                <i class="material-icons">login</i>
                Register
            </button>
            <div id="status"></div>
        </div>

        <div id="softphone-ui" style="display:none;">
            <div class="number-display-container">
                <div id="display" class="display-with-clear">
                    <span id="display-text"></span>
                    <button id="clearBtn" class="clear-button">
                        <i class="material-icons">backspace</i>
                    </button>
                </div>
                <button id="toggleDialpad" class="toggle-dialpad">
                    <i class="material-icons">dialpad</i>
                </button>
            </div>
            
            <div id="dialpadContainer" class="dialpad-container hidden">
                <div class="dialpad">
                    <button class="dial-digit" data-digit="1">1</button>
                    <button class="dial-digit" data-digit="2">2</button>
                    <button class="dial-digit" data-digit="3">3</button>
                    <button class="dial-digit" data-digit="4">4</button>
                    <button class="dial-digit" data-digit="5">5</button>
                    <button class="dial-digit" data-digit="6">6</button>
                    <button class="dial-digit" data-digit="7">7</button>
                    <button class="dial-digit" data-digit="8">8</button>
                    <button class="dial-digit" data-digit="9">9</button>
                    <button class="dial-digit" data-digit="*">*</button>
                    <button class="dial-digit" data-digit="0">0</button>
                    <button class="dial-digit" data-digit="#">#</button>
                </div>
            </div>

            <div id="captionContainer" class="caption-container hidden">
                <div id="captions" class="captions"></div>
            </div>

            <div id="mic-status">
                <i class="material-icons">mic</i>
                <span id="selected-mic-name"></span>
                <span>ready</span>
            </div>
            <div class="button-container">
                <div class="button-wrapper" id="callBtnWrapper">
                    <button id="callBtn" class="call-button">
                        <i class="material-icons">call</i>
                        Call
                    </button>
                </div>
                <div class="button-wrapper hidden" id="answerBtnWrapper">
                    <button id="answerBtn" class="answer-button">
                        <i class="material-icons">call</i>
                        Answer
                    </button>
                </div>
                <div class="button-wrapper hidden" id="hangupBtnWrapper">
                    <button id="hangupBtn" class="hangup-button">
                        <i class="material-icons">call_end</i>
                        Hang Up
                    </button>
                </div>
                <div class="button-wrapper hidden" id="recordBtnWrapper">
                    <button id="recordBtn" class="record-button">
                        <i class="material-icons">fiber_manual_record</i>
                        Record
                    </button>
                </div>
                <div class="button-wrapper hidden" id="downloadBtnWrapper">
                    <button id="downloadBtn" class="download-button">
                        <i class="material-icons">download</i>
                        Download Recording
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
    (function() {
        let userAgent;
        let session;
        const statusDisplay = document.getElementById('status');
        let currentMicId = null;
        let currentSpeakerId = null;
        let stream = null;
        let callTimer;
        let callStartTime;
        let ringtoneAudio = new Audio();
        let selectedRingtone = null;
        let captioningSystem = null;
        let mediaRecorder;
        let recordedChunks = [];
        let isRecording = false;

        function updateStatus(status, color = 'black') {
            console.log('Status:', status);
            statusDisplay.textContent = status;
            statusDisplay.style.color = color;
        }

        document.getElementById('registerBtn').addEventListener('click', function() {
            const sipUri = document.getElementById('username').value;
            const password = document.getElementById('password').value;
            const sipServer = document.getElementById('sipServer').value;
            
            if (!sipUri || !password || !sipServer) {
                updateStatus('Please fill in all registration fields.', 'red');
                return;
            }

            try {
                const socket = new JsSIP.WebSocketInterface(sipServer);
                const configuration = {
                    sockets: [socket],
                    uri: sipUri,
                    password: password,
                    register: true,
                    register_expires: 300,
                    session_timers: false,
                    user_agent: 'Open Phone WebRTC',
                    connection_recovery_min_interval: 2,
                    connection_recovery_max_interval: 30
                };

                console.log('Attempting connection with config:', {
                    ...configuration,
                    password: '***'
                });

                userAgent = new JsSIP.UA(configuration);

                userAgent.on('connected', function() {
                    updateStatus('WebSocket Connected - Registering...', 'blue');
                    console.log('UA connected!');
                });

                userAgent.on('disconnected', function() {
                    updateStatus('WebSocket Disconnected', 'red');
                    console.log('UA disconnected');
                });

                userAgent.on('registered', function() {
                    navigator.mediaDevices.getUserMedia({ audio: true })
                        .then(() => loadAudioDevices())
                        .then(() => {
                        // Create or get audio element
                        let audioElement = document.getElementById('remoteAudio');
                        if (!audioElement) {
                            audioElement = document.createElement('audio');
                            audioElement.id = 'remoteAudio';
                            audioElement.autoplay = true;
                            document.body.appendChild(audioElement);
                        }
                        
                        // Set initial speaker if available
                        if (typeof audioElement.sinkId !== 'undefined' && currentSpeakerId) {
                                return audioElement.setSinkId(currentSpeakerId);
                            }
                        })
                        .then(() => {
                        document.getElementById('status').textContent = 'Ready';
                        document.getElementById('softphone-ui').style.display = 'block';
                        document.getElementById('registration').style.display = 'none';
                        })
                        .catch(error => {
                        console.error('Setup error:', error);
                        document.getElementById('mic-status').classList.add('error');
                        document.getElementById('selected-mic-name').textContent = 'Audio setup failed';
                        });
                });

                userAgent.on('registrationFailed', function(error) {
                    document.getElementById('status').textContent = 'Registration failed: ' + error.cause;
                });

                userAgent.on('newRTCSession', function(data) {
                    session = data.session;
                    
                    if (session.direction === 'incoming') {
                        console.log('Incoming call received');
                        showAnswerButton();
                        updateCallStatus('Incoming Call');
                        
                        // Play ringtone
                        if (ringtoneAudio.src) {
                            ringtoneAudio.loop = true;
                            ringtoneAudio.play().catch(e => console.error('Error playing ringtone:', e));
                        }
                        
                        // Set up session handlers
                        setupSessionHandlers(session);
                    }
                });

                userAgent.start();

                        } catch (error) {
                updateStatus(`Error creating user agent: ${error.message}`, 'red');
                console.error('Full error:', error);
            }
        });

        document.getElementById('answerBtn').addEventListener('click', function() {
            if (session) {
                stopRingtone();
                try {
                    session.answer({
                        mediaConstraints: { audio: true, video: false }
                    }).then(() => {
                        console.log('Call answered successfully');
                    }).catch(error => {
                        console.error('Error answering call:', error);
                        updateCallStatus('Failed to answer');
                    });
                    
                    setupSessionHandlers(session);
                    showHangupButton();
                    updateCallStatus('Connected');
                    startSpeechRecognition();
                    showCaptionContainer();
                } catch (error) {
                    console.error('Exception answering call:', error);
                    updateCallStatus('Failed to answer');
                }
            }
        });

        document.getElementById('hangupBtn').addEventListener('click', function() {
            if (session) {
                session.terminate();
                handleCallEnded();
            }
        });

        const displayText = document.getElementById('display-text');
        document.querySelectorAll('.dial-digit').forEach(function(button) {
            button.addEventListener('click', function() {
                displayText.textContent += this.getAttribute('data-digit');
            });
        });

        document.getElementById('clearBtn').addEventListener('click', function() {
            displayText.textContent = '';
        });

        async function loadAudioDevices() {
            try {
                await navigator.mediaDevices.getUserMedia({ audio: true });
                const devices = await navigator.mediaDevices.enumerateDevices();
                const micSelect = document.getElementById('micSelect');
                const speakerSelect = document.getElementById('speakerSelect');
                
                micSelect.innerHTML = '';
                speakerSelect.innerHTML = '';

                // Handle microphones
                const mics = devices.filter(device => device.kind === 'audioinput');
                mics.forEach(device => {
                    const option = new Option(device.label || `Microphone (${device.deviceId.slice(0,5)})`, device.deviceId);
                    micSelect.add(option);
                });

                // Handle speakers
                const speakers = devices.filter(device => device.kind === 'audiooutput');
                speakers.forEach(device => {
                    const option = new Option(device.label || `Speaker (${device.deviceId.slice(0,5)})`, device.deviceId);
                    speakerSelect.add(option);
                });

                // Load saved preferences
                const savedMicId = localStorage.getItem('preferredMicId');
                const savedSpeakerId = localStorage.getItem('preferredSpeakerId');

                if (savedMicId && micSelect.querySelector(`option[value="${savedMicId}"]`)) {
                    micSelect.value = savedMicId;
                    currentMicId = savedMicId;
                }

                if (savedSpeakerId && speakerSelect.querySelector(`option[value="${savedSpeakerId}"]`)) {
                    speakerSelect.value = savedSpeakerId;
                    currentSpeakerId = savedSpeakerId;
                }

                updateMicDisplay(micSelect);

                // Create audio element if it doesn't exist
                if (!document.getElementById('remoteAudio')) {
                    const audioElement = document.createElement('audio');
                    audioElement.id = 'remoteAudio';
                    audioElement.autoplay = true;
                    
                    if (typeof audioElement.sinkId !== 'undefined' && currentSpeakerId) {
                        await audioElement.setSinkId(currentSpeakerId)
                            .catch(error => console.error('Error setting audio output:', error));
                    }
                    
                    document.body.appendChild(audioElement);
                }

                // Update mic status to show success
                document.getElementById('mic-status').classList.remove('error');
                document.getElementById('selected-mic-name').textContent = micSelect.options[micSelect.selectedIndex].text;

            } catch (error) {
                console.error('Error loading audio devices:', error);
                document.getElementById('mic-status').classList.add('error');
                document.getElementById('selected-mic-name').textContent = 'Audio device access error';
            }
        }

        function updateMicDisplay(micSelect) {
            const selectedMicName = micSelect.options[micSelect.selectedIndex]?.text || 'Default Microphone';
            const truncatedName = selectedMicName.length > 30 ? 
                selectedMicName.substring(0, 30) + '...' : 
                selectedMicName;
            document.getElementById('selected-mic-name').textContent = truncatedName;
            document.getElementById('selected-mic-name').title = selectedMicName;
        }

        async function handleDeviceChange() {
            const micSelect = document.getElementById('micSelect');
            const speakerSelect = document.getElementById('speakerSelect');

            currentMicId = micSelect.value;
            currentSpeakerId = speakerSelect.value;

            updateMicDisplay(micSelect);

            localStorage.setItem('preferredMicId', currentMicId);
            localStorage.setItem('preferredSpeakerId', currentSpeakerId);

            // Update audio output device
            const audioElement = document.getElementById('remoteAudio');
            if (audioElement && typeof audioElement.sinkId !== 'undefined') {
                try {
                    await audioElement.setSinkId(currentSpeakerId);
                    console.log('Speaker changed:', {
                        newSpeakerId: currentSpeakerId,
                        audioElement: audioElement,
                        sinkIdSupported: typeof audioElement.sinkId !== 'undefined'
                    });
                } catch (error) {
                    console.error('Error switching speaker:', error);
                }
            }
        }

        document.getElementById('settingsBtn').addEventListener('click', async () => {
            try {
                document.getElementById('settingsModal').style.display = 'flex';
                await loadAudioDevices();
            } catch (error) {
                console.error('Error opening settings:', error);
                alert('Error accessing audio devices. Please ensure you have granted microphone permissions.');
            }
        });

        document.querySelector('.close-btn').addEventListener('click', () => {
            document.getElementById('settingsModal').style.display = 'none';
        });

        document.getElementById('micSelect').addEventListener('change', handleDeviceChange);
        document.getElementById('speakerSelect').addEventListener('change', handleDeviceChange);

        navigator.mediaDevices.addEventListener('devicechange', async () => {
            console.log('Audio devices changed, reloading device list...');
            if (document.getElementById('settingsModal').style.display === 'flex') {
                await loadAudioDevices();
            }
        });

        function updateCallStatus(state, isConnected = false) {
            const callStatus = document.getElementById('call-status');
            const callState = document.getElementById('call-state');
            const callTimerDisplay = document.getElementById('call-timer');
            
            callStatus.style.display = 'block';
            callState.textContent = state;

            if (state === 'Connected') {
                callStatus.style.backgroundColor = '#e8f5e9';
                callState.parentElement.classList.remove('calling');
                callState.parentElement.style.color = '#34a853';
                
                if (!callTimer) {
                    callStartTime = Date.now();
                    callTimer = setInterval(updateCallTimer, 1000);
                }
            } else if (state === 'Ended') {
                clearInterval(callTimer);
                callTimer = null;
                setTimeout(() => {
                    callStatus.style.display = 'none';
                    callTimerDisplay.textContent = '00:00:00';
                }, 2000);
            } else {
                callStatus.style.backgroundColor = '#e3f2fd';
                callState.parentElement.classList.add('calling');
                callState.parentElement.style.color = '#1a73e8';
            }
        }

        function updateCallTimer() {
            const callTimerDisplay = document.getElementById('call-timer');
            const elapsed = Math.floor((Date.now() - callStartTime) / 1000);
            
            const hours = Math.floor(elapsed / 3600);
            const minutes = Math.floor((elapsed % 3600) / 60);
            const seconds = elapsed % 60;
            
            callTimerDisplay.textContent = 
                `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        window.addEventListener('beforeunload', () => {
            if (callTimer) {
                clearInterval(callTimer);
            }
        });

        document.getElementById('toggleDialpad').addEventListener('click', function() {
            const dialpadContainer = document.getElementById('dialpadContainer');
            const toggleButton = document.getElementById('toggleDialpad');
            const dialpad = document.querySelector('.dialpad');
            
            if (dialpadContainer.classList.contains('hidden')) {
                dialpadContainer.classList.remove('hidden');
                dialpadContainer.offsetHeight;
                dialpadContainer.style.height = dialpad.offsetHeight + 'px';
                dialpadContainer.classList.add('visible');
                toggleButton.classList.add('active');
            } else {
                dialpadContainer.style.height = '0';
                dialpadContainer.classList.remove('visible');
                toggleButton.classList.remove('active');
                
                setTimeout(() => {
                    if (dialpadContainer.style.height === '0px') {
                        dialpadContainer.classList.add('hidden');
                    }
                }, 300);
            }
        });

        window.addEventListener('load', function() {
            const dialpadContainer = document.getElementById('dialpadContainer');
            const dialpad = document.querySelector('.dialpad');
            if (!dialpadContainer.classList.contains('hidden')) {
                dialpadContainer.style.height = dialpad.offsetHeight + 'px';
                dialpadContainer.classList.add('visible');
            }
        });

        function showCallButton() {
            document.getElementById('callBtnWrapper').classList.remove('hidden');
            document.getElementById('answerBtnWrapper').classList.add('hidden');
            document.getElementById('hangupBtnWrapper').classList.add('hidden');
        }

        function showAnswerButton() {
            document.getElementById('callBtnWrapper').classList.add('hidden');
            document.getElementById('answerBtnWrapper').classList.remove('hidden');
            document.getElementById('hangupBtnWrapper').classList.add('hidden');
        }

        function showHangupButton() {
            document.getElementById('callBtnWrapper').classList.add('hidden');
            document.getElementById('answerBtnWrapper').classList.add('hidden');
            document.getElementById('hangupBtnWrapper').classList.remove('hidden');
            document.getElementById('recordBtnWrapper').classList.remove('hidden');
            document.getElementById('downloadBtnWrapper').classList.add('hidden');
        }

        // Initialize ringtone from localStorage if available
        document.addEventListener('DOMContentLoaded', () => {
            const savedRingtone = localStorage.getItem('ringtoneData');
            if (savedRingtone) {
                ringtoneAudio.src = savedRingtone;
                const ringtoneName = localStorage.getItem('ringtoneName') || 'Custom Ringtone';
                document.getElementById('selectedRingtoneName').textContent = ringtoneName;
            }
        });

        document.getElementById('selectRingtone').addEventListener('click', () => {
            document.getElementById('ringtoneInput').click();
        });

        document.getElementById('ringtoneInput').addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    ringtoneAudio.src = e.target.result;
                    selectedRingtone = e.target.result;
                    document.getElementById('selectedRingtoneName').textContent = file.name;
                    
                    // Save to localStorage
                    localStorage.setItem('ringtoneData', e.target.result);
                    localStorage.setItem('ringtoneName', file.name);
                };
                reader.readAsDataURL(file);
            }
        });

        document.getElementById('playRingtone').addEventListener('click', () => {
            if (ringtoneAudio.paused) {
                ringtoneAudio.play();
                document.getElementById('playRingtone').querySelector('i').textContent = 'stop';
            } else {
                ringtoneAudio.pause();
                ringtoneAudio.currentTime = 0;
                document.getElementById('playRingtone').querySelector('i').textContent = 'play_arrow';
            }
        });

        ringtoneAudio.addEventListener('ended', () => {
            document.getElementById('playRingtone').querySelector('i').textContent = 'play_arrow';
        });

        function stopRingtone() {
            ringtoneAudio.pause();
            ringtoneAudio.currentTime = 0;
            ringtoneAudio.loop = false;
        }

        function startSpeechRecognition() {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (SpeechRecognition) {
                // Stop any existing recognition
                if (window.recognition) {
                    window.recognition.stop();
                }
                
                let recognition = new SpeechRecognition();
                recognition.lang = 'en-US';
                recognition.interimResults = true;
                recognition.continuous = true;
                
                // Set a longer timeout before giving up on speech
                recognition.maxAlternatives = 3;
                
                // Handle no-speech errors by restarting
                recognition.onerror = function(event) {
                    console.log('Speech recognition error:', event.error);
                    
                    // If it's a no-speech error, restart recognition after a short delay
                    if (event.error === 'no-speech') {
                        setTimeout(() => {
                            if (window.recognition) {
                                try {
                                    window.recognition.start();
                                    console.log('Restarted speech recognition after no-speech error');
                                } catch (e) {
                                    console.log('Failed to restart recognition:', e);
                                }
                            }
                        }, 1000);
                    }
                };
                
                recognition.onend = function() {
                    console.log('Speech recognition ended');
                    // Restart if it ends unexpectedly and we still have an active call
                    if (session && session.isEstablished() && window.recognition) {
                        try {
                            window.recognition.start();
                            console.log('Restarted speech recognition after unexpected end');
                        } catch (e) {
                            console.log('Failed to restart recognition after end:', e);
                        }
                    }
                };

                recognition.onresult = function(event) {
                    console.log('Speech recognition result received');
                    const transcript = Array.from(event.results)
                        .map(result => result[0])
                        .map(result => result.transcript)
                        .join('');
                    
                    document.getElementById('captions').textContent = transcript;
                    console.log('Transcript:', transcript);
                };

                try {
                    recognition.start();
                    console.log('Speech recognition started');
                } catch (e) {
                    console.error('Error starting speech recognition:', e);
                }
                
                // Store recognition globally so we can stop it later
                window.recognition = recognition;
            } else {
                console.warn('Speech recognition not supported in this browser.');
                // Show a message in the captions container
                document.getElementById('captions').textContent = 'Speech recognition not supported in this browser';
            }
        }

        function showCaptionContainer() {
            const captionContainer = document.getElementById('captionContainer');
            captionContainer.classList.remove('hidden');
            captionContainer.style.display = 'flex'; // Explicitly set display to flex
            console.log('Caption container shown:', captionContainer);
            
            // Add debug button for testing
            addCaptionDebugButton();
            
            // Initialize with a welcome message
            updateCaptions("Call connected. Captions will appear here...");
        }

        function hideCaptionContainer() {
            const captionContainer = document.getElementById('captionContainer');
            captionContainer.classList.add('hidden');
            captionContainer.style.display = 'none'; // Explicitly set display to none
        }

        // Updated startCallTimer function to use existing timer element
        function startCallTimer() {
            console.log('Starting call timer');
            
            // Clear any existing timer
            if (window.callTimerInterval) {
                clearInterval(window.callTimerInterval);
            }
            
            // Initialize call start time
            window.callStartTime = new Date();
            
            // Find the existing call timer element
            let timerElement = document.querySelector('.call-timer');
            
            // If it doesn't exist, look for one with the ID
            if (!timerElement) {
                timerElement = document.getElementById('callTimer');
            }
            
            // If we still don't have a timer element, don't create a new one
            // as it would be outside the design
            if (!timerElement) {
                console.warn('No call timer element found with class .call-timer or id #callTimer');
                return;
            }
            
            // Make sure the timer is visible
            timerElement.style.display = 'block';
            timerElement.textContent = '00:00';
            
            // Update timer every second
            window.callTimerInterval = setInterval(() => {
                const now = new Date();
                const diff = now - window.callStartTime;
                const minutes = Math.floor(diff / 60000);
                const seconds = Math.floor((diff % 60000) / 1000);
                timerElement.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }, 1000);
        }

        // Updated stopCallTimer function
        function stopCallTimer() {
            const timerInterval = window.callTimerInterval;
            if (timerInterval) {
                window.callTimerInterval = null;
                clearInterval(timerInterval);
            }
        }

        function hideDialpadContainer() {
            const dialpadContainer = document.getElementById('dialpadContainer');
            dialpadContainer.style.height = '0';
            dialpadContainer.classList.add('hidden');
            setTimeout(() => {
                if (dialpadContainer.style.height === '0px') {
                    dialpadContainer.classList.add('hidden');
                }
            }, 300);
        }

        // Add this after your existing event listeners
        document.addEventListener('DOMContentLoaded', function() {
            const displayText = document.getElementById('display-text');
            
            // Allow the display to be focusable
            displayText.setAttribute('contenteditable', 'true');
            displayText.setAttribute('spellcheck', 'false');
            
            // Handle keyboard input
            displayText.addEventListener('keydown', function(e) {
                // Prevent default behavior for most keys to handle them manually
                if (e.key !== 'Tab') {
                    e.preventDefault();
                }

                // Handle numeric input (0-9, *, #)
                const validKeys = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '*', '#'];
                if (validKeys.includes(e.key)) {
                    const currentText = displayText.textContent;
                    displayText.textContent = currentText + e.key;
                }
                
                // Handle backspace
                if (e.key === 'Backspace') {
                    const currentText = displayText.textContent;
                    displayText.textContent = currentText.slice(0, -1);
                }
                
                // Handle Enter key to trigger call
                if (e.key === 'Enter') {
                    const callButton = document.querySelector('.call-button');
                    if (callButton && !callButton.classList.contains('hidden')) {
                        callButton.click();
                    }
                }
            });

            // Prevent pasting non-numeric content
            displayText.addEventListener('paste', function(e) {
                e.preventDefault();
                const pastedText = (e.clipboardData || window.clipboardData).getData('text');
                const numericOnly = pastedText.replace(/[^0-9*#]/g, '');
                if (numericOnly) {
                    displayText.textContent += numericOnly;
                }
            });

            // Keep focus in the display when typing
            displayText.addEventListener('blur', function() {
                displayText.focus();
            });
        });

        // Add this function to test audio playback
        function testAudioPlayback() {
            const audioElement = document.getElementById('remoteAudio');
            if (audioElement && audioElement.srcObject) {
                console.log('Testing audio playback...');
                
                // Log current audio state
                console.log('Audio element state:', {
                    muted: audioElement.muted,
                    volume: audioElement.volume,
                    paused: audioElement.paused,
                    ended: audioElement.ended,
                    readyState: audioElement.readyState,
                    hasAudioTracks: audioElement.srcObject.getAudioTracks().length > 0,
                    audioTrackEnabled: audioElement.srcObject.getAudioTracks()[0]?.enabled
                });
                
                // Ensure it's not muted and volume is up
                audioElement.muted = false;
                audioElement.volume = 1.0;
                
                // Try to play
                audioElement.play().then(() => {
                    console.log('Audio playback started successfully');
                }).catch(e => {
                    console.error('Audio playback test failed:', e);
                });
            } else {
                console.error('No audio element or no stream attached');
            }
        }

        // Call this function after the call is established
        // You can also add a button to trigger this manually for testing

        // Add this function to test audio
        function testAudio() {
            // Create a simple audio context
            const audioContext = new AudioContext();
            
            // Create an oscillator
            const oscillator = audioContext.createOscillator();
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(440, audioContext.currentTime); // 440 Hz - A4
            
            // Connect to output
            oscillator.connect(audioContext.destination);
            
            // Start and stop after 1 second
            oscillator.start();
            setTimeout(() => {
                oscillator.stop();
                console.log('Audio test complete - you should have heard a beep');
            }, 1000);
            
            console.log('Testing audio output - you should hear a beep');
        }

        // Call this function to test audio
        // testAudio();

        function validatePhoneNumber(number) {
            const cleaned = number.replace(/\D/g, '');
            if (!/^\d{10,15}$/.test(cleaned)) {
                throw new Error('Invalid phone number format');
            }
            return cleaned;
        }

        function checkBrowserSupport() {
            const features = {
                webRTC: !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia),
                speechRecognition: !!(window.SpeechRecognition || window.webkitSpeechRecognition),
                audioOutput: !!(typeof HTMLAudioElement !== 'undefined' && HTMLAudioElement.prototype.setSinkId)
            };
            
            return features;
        }

        function setupRecording(session) {
            const recordBtn = document.getElementById('recordBtn');
            const downloadBtn = document.getElementById('downloadBtn');
            
            recordBtn.addEventListener('click', async () => {
                try {
                    if (!isRecording) {
                        await startRecording(session);
                    } else {
                        stopRecording();
                    }
                } catch (error) {
                    console.error('Recording error:', error);
                }
            });

            downloadBtn.addEventListener('click', () => {
                downloadRecording();
            });
        }

        async function startRecording(session) {
            try {
                recordedChunks = [];
                const audioStreams = [];

                // Get remote stream from the audio element
                const remoteAudio = document.getElementById('remoteAudio');
                if (remoteAudio && remoteAudio.srcObject) {
                    audioStreams.push(remoteAudio.srcObject);
                }

                // Get local stream
                const localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                audioStreams.push(localStream);

                // Combine streams
                const ctx = new AudioContext();
                const dest = ctx.createMediaStreamDestination();
                
                audioStreams.forEach(stream => {
                    if (stream.getAudioTracks().length > 0) {
                        const source = ctx.createMediaStreamSource(stream);
                        source.connect(dest);
                    }
                });

                // Create MediaRecorder
                mediaRecorder = new MediaRecorder(dest.stream);

                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };

                mediaRecorder.onstop = () => {
                    document.getElementById('downloadBtnWrapper').classList.remove('hidden');
                };

                // Start recording
                mediaRecorder.start();
                isRecording = true;
                
                // Update UI
                const recordBtn = document.getElementById('recordBtn');
                recordBtn.classList.add('recording');
                recordBtn.innerHTML = '<i class="material-icons">stop</i>Stop Recording';
                
                console.log('Recording started');
            } catch (error) {
                console.error('Error starting recording:', error);
                alert('Failed to start recording: ' + error.message);
            }
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
                isRecording = false;
                
                // Update UI
                const recordBtn = document.getElementById('recordBtn');
                recordBtn.classList.remove('recording');
                recordBtn.innerHTML = '<i class="material-icons">fiber_manual_record</i>Record';
                
                console.log('Recording stopped');
            }
        }

        function downloadRecording() {
            if (recordedChunks.length === 0) {
                console.warn('No recording data available');
                return;
            }
            
            const blob = new Blob(recordedChunks, { type: 'audio/webm' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            a.href = url;
            a.download = `call-recording-${timestamp}.webm`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function setupSessionHandlers(session) {
            session.on('peerconnection', (e) => {
                console.log('Peer connection event');
                const peerconnection = e.peerconnection;
                
                peerconnection.ontrack = (trackEvent) => {
                    console.log('Received remote track:', trackEvent);
                    const audioElement = document.getElementById('remoteAudio');
                    if (!audioElement) {
                        console.error('Audio element not found');
                        return;
                    }
                    
                    if (trackEvent.track.kind === 'audio') {
                        console.log('Setting remote audio stream');
                        audioElement.srcObject = trackEvent.streams[0];
                        audioElement.play().catch(err => {
                            console.error('Error playing audio:', err);
                        });
                    }
                };
            });

            // Add these event handlers to detect call termination
            session.on('ended', function() {
                console.log('Call ended by remote party');
                handleCallEnded();
            });
            
            session.on('failed', function() {
                console.log('Call failed');
                handleCallEnded();
            });

            session.on('accepted', function() {
                console.log('Call accepted');
                updateCallStatus('Connected');
                showHangupButton();
                callStartTime = Date.now();
                callTimer = setInterval(updateCallTimer, 1000);
                setupRecording(session);
                startSpeechRecognition();
                showCaptionContainer();
            });
        }

        // Add this function to handle call ending from any source
        function handleCallEnded() {
            updateCallStatus('Ended');
            showCallButton();
            stopRingtone();
            stopSpeechRecognition();
            hideCaptionContainer();
            
            // Make sure to clear the timer
            if (callTimer) {
                clearInterval(callTimer);
                callTimer = null;
            }
        }

        function stopSpeechRecognition() {
            if (window.recognition) {
                window.recognition.stop();
                window.recognition = null;
            }
        }

        // Add this after the other button handlers
        document.getElementById('callBtn').addEventListener('click', function() {
            const number = document.getElementById('display-text').textContent.trim();
            if (!number) {
                alert('Please enter a number to call');
                return;
            }
            
            try {
                // Create a simple URI for the call
                const target = `sip:${number}@${userAgent.configuration.uri.host}`;
                
                // Start the call
                session = userAgent.call(target, {
                    mediaConstraints: { audio: true, video: false },
                    pcConfig: {
                        iceServers: [
                            { urls: ['stun:stun.l.google.com:19302'] }
                        ]
                    }
                });
                
                // Set up session handlers
                setupSessionHandlers(session);
                
                // Update UI
                updateCallStatus('Calling...');
                showHangupButton();
                
            } catch (error) {
                console.error('Error making call:', error);
                alert('Failed to make call: ' + error.message);
            }
        });

        // Add this function to manually update captions
        function updateCaptions(text) {
            const captionsElement = document.getElementById('captions');
            if (captionsElement) {
                captionsElement.textContent = text;
            }
        }

        // Add a function to simulate captions for testing
        function simulateCaptions() {
            if (session && session.isEstablished()) {
                const phrases = [
                    "Hello, can you hear me?",
                    "I'm calling about your recent inquiry",
                    "Could you please provide more information?",
                    "Thank you for your patience",
                    "Let me check that for you",
                    "I'll need to verify some information",
                    "Is there anything else I can help with?",
                    "Please hold while I look into that"
                ];
                
                const randomPhrase = phrases[Math.floor(Math.random() * phrases.length)];
                updateCaptions(randomPhrase);
                
                // Schedule next caption update
                setTimeout(simulateCaptions, 5000);
            }
        }

        // Add a debug button to the caption container
        function addCaptionDebugButton() {
            const captionContainer = document.getElementById('captionContainer');
            if (captionContainer) {
                const debugBtn = document.createElement('button');
                debugBtn.textContent = "Test Captions";
                debugBtn.style.position = "absolute";
                debugBtn.style.bottom = "5px";
                debugBtn.style.right = "5px";
                debugBtn.style.fontSize = "12px";
                debugBtn.style.padding = "2px 5px";
                debugBtn.style.background = "#1a73e8";
                debugBtn.style.color = "white";
                debugBtn.style.border = "none";
                debugBtn.style.borderRadius = "4px";
                
                debugBtn.addEventListener('click', function() {
                    updateCaptions("Caption test - " + new Date().toLocaleTimeString());
                    // Start simulated captions
                    simulateCaptions();
                });
                
                captionContainer.appendChild(debugBtn);
            }
        }
    })();
    </script>
</body>
</html>
